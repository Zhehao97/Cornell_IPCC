import numpy as npimport pandas as pdimport matplotlib.pyplot as pltdef PortfolioPrices(Portfolio, w_equity, col_names, trade_years):    value = 1000  # initial assets    LV = []       # a list stores the value    # intialize the weights    w_E = w_equity    w_agg = 0.8    # the start price of components    px_array = Portfolio[col_names.values()].iloc[0, :].values    for year in trade_years:        if np.isnan(px_array[2]):  # px_russell is nan            w_E = 0        if np.isnan(px_array[1]):  # px_agg is nan            w_agg = 0        if np.isnan(px_array[0]):  # px_tbill is nan            w_agg = 1        # derive the weights of different components        w_russell = w_E        w_agg = (1 - w_E) * w_agg        w_tbill = (1 - w_E) * (1 - w_agg)        weight_array = np.array([w_tbill, w_agg, w_russell])        # rebalance the value & share at the start of each year        value_array = value * weight_array        shares_array = value_array / px_array        for idx, row in Portfolio[Portfolio.index.year == year].iterrows():            px_array = Portfolio[col_names.values()].loc[idx, :].values            # update the value of different components            value_array = np.nan_to_num(shares_array * px_array)            # update the value of portfolio            value = np.sum(value_array)            # store the value of portfolio            LV.append(value)        # restore the weights        w_E = w_equity        c_agg = 0.8    return LVdef Age_Risk_Map(age, risk_pref=1, coef=8):    k = 5000    y = (68 - age)/(coef * risk_pref) + k/(age)**2    return ydef AgeRiskPlot(x):    fig, axs = plt.subplots(nrows=1, ncols=1, sharex=True, figsize=(15,10))    for i in range(1,5):        y = Age_Risk_Map(x, risk_pref=i)        axs.plot(x, y, label='risk pref=' + str(i))    axs.set_xlabel('Age')    axs.set_ylabel('Volatility Tolerance (%)')    axs.set_title('Mapping from Age to Volatility Tolerance')    axs.legend()    plt.show()def StdToRatio(Train_Std, Std_Matrix):        Ratio_Matrix = Std_Matrix.copy()        for i in range(Std_Matrix.shape[0]):        for j in range(Std_Matrix.shape[1]):                temp_train_std = list(Train_Std).copy()            temp_train_std.append(Std_Matrix[i][j])            temp_train_std.sort()            idx = temp_train_std.index(Std_Matrix[i][j])            if idx == 8 or idx == 9:                Ratio_Matrix[i][j] = 8            else:                Ratio_Matrix[i][j] = np.int(idx)        return Ratio_Matrixdef ReturnCalculate(DF, ratio_lst):    col_names = []    col_idx = list(set(ratio_lst))        for i in col_idx:        col_names.append(DF.columns[i])        DF_return = DF[col_names] + 1    DF_return = DF_return.cumprod()    return DF_returndef ReturnPlot(DF, ratio_matrix):    fig, axes = plt.subplots(nrows=5, ncols=1)    for i in range(ratio_matrix.shape[0]):        df = ReturnCalculate(DF, ratio_matrix[i])        df.plot(ax=axes[i], figsize=(16,12))    return def StdPlot(Train_AnnSTD, Test_AnnSTD, title_name='Index'):        plt.figure(figsize=(16,8))    x_train = np.array(Train_AnnSTD.values)    y_train = np.array(Train_AnnSTD.index)    x_test = np.array(Test_AnnSTD.values)    y_test = np.array(Test_AnnSTD.index)    plt.plot(x_train, y_train, drawstyle='steps', label='Steps of Train Set')    plt.plot(x_train, y_train, label='Curve of Train Set')    plt.plot(x_test, y_test, drawstyle='steps', label='Steps of Test Set')    plt.plot(x_test, y_test, label='Curve of Test Set')    plt.legend()    plt.xlabel('Std of Different Ratio')    plt.ylabel('Ratio (Equity/Bond)')    plt.title(title_name)    plt.show()    return