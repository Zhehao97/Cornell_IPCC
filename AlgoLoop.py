import numpy as npimport pandas as pddef PortfolioPrices(Portfolio, w_equity, col_names, trade_years):    value = 1000  # initial assets    LV = []       # a list stores the value    # intialize the weights    w_E = w_equity    w_agg = 0.8    # the start price of components    px_array = Portfolio[col_names.values()].iloc[0, :].values    for year in trade_years:        if np.isnan(px_array[2]):  # px_russell is nan            w_E = 0        if np.isnan(px_array[1]):  # px_agg is nan            w_agg = 0        if np.isnan(px_array[0]):  # px_tbill is nan            w_agg = 1        # derive the weights of different components        w_russell = w_E        w_agg = (1 - w_E) * w_agg        w_tbill = (1 - w_E) * (1 - w_agg)        weight_array = np.array([w_tbill, w_agg, w_russell])        # rebalance the value & share at the start of each year        value_array = value * weight_array        shares_array = value_array / px_array        for idx, row in Portfolio[Portfolio.index.year == year].iterrows():            px_array = Portfolio[col_names.values()].loc[idx, :].values            # update the value of different components            value_array = np.nan_to_num(shares_array * px_array)            # update the value of portfolio            value = np.sum(value_array)            # store the value of portfolio            LV.append(value)        # restore the weights        w_E = w_equity        c_agg = 0.8    return LVdef StdToRatio(Train_Std, Std_Matrix):        Ratio_Matrix = Std_Matrix.copy()        for i in range(Std_Matrix.shape[0]):        for j in range(Std_Matrix.shape[1]):                temp_train_std = list(Train_Std).copy()            temp_train_std.append(Std_Matrix[i][j])            temp_train_std.sort()            idx = temp_train_std.index(Std_Matrix[i][j])            if idx == 8 or idx == 9:                Ratio_Matrix[i][j] = 8            else:                Ratio_Matrix[i][j] = np.int(idx)        return Ratio_Matrix